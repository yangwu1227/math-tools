{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A small math utility package that started with Linear Algebra MATH 224 at Kenyon College.</p>"},{"location":"linear_algebra/","title":"Linear Algebra","text":""},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps","title":"<code>MatrixOps</code>","text":"<p>               Bases: <code>object</code></p> <p>A matrix utility class that provides a set of methods for matrix operations.</p> <p>Attributes:</p> Name Type Description <code>X (np.ndarray)</code> <code>A matrix.</code> <code>row (int)</code> <code>Number of rows.</code> <code>col (int)</code> <code>Number of columns.</code> <code>det (np.ndarray)</code> <code>The determinant of X, if it is square.</code>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.__init__","title":"<code>__init__(X, axis=None)</code>","text":"<p>Initialize the MatrixOps instance.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[ndarray, List[List[Any]], Tuple[Tuple[Any]]]</code> <p>A matrix or a sequence that represents the matrix.</p> required <code>axis</code> <code>Optional[int]</code> <p>The axis along which the sequence is stacked into a matrix. Required if X is a sequence.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.__repr__","title":"<code>__repr__()</code>","text":"<p>Delegate to numpy's representation.</p>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.approx_rank_k","title":"<code>approx_rank_k(k)</code>","text":"<p>Computes the rank-k approximation of the matrix X. The matrix approximation can be constructed as the matrix product <code>u @ np.diag(s) @ vh</code> where (u, s, vh) are the tuple returned by calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The rank of the approximation.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>The singular values, left, right singular vectors needed to construct the rank-k approximation of the matrix X.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 0, 12], [7, 12, 17], [9, 77, 27], [8, 7, 16]], axis=0)\n&gt;&gt;&gt; m.approx_rank_k(1)\n(array([[-0.05593827],\n        [-0.2166436 ],\n        [-0.96140112],\n        [-0.16013852]]),\n array([85.19359971]),\n array([[-0.13505899, -0.91261056, -0.38587696]]))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.char_poly","title":"<code>char_poly()</code>","text":"<p>Computes characteristic polynomial det(lambda*I - M) where I is the identity matrix.</p> <p>Returns:</p> Type Description <code>sympy expression</code> <p>A class instance inheriting from the Base class for algebraic expressions <code>Expr</code>.</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>The matrix X must be square.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [3, 4]], axis=0)\n&gt;&gt;&gt; m.char_poly()\nlambda**2 - 5*lambda - 2\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.cob_mat","title":"<code>cob_mat(original_basis, new_basis, inv=False)</code>  <code>staticmethod</code>","text":"<p>Find the change of basis matrix <code>S</code> from <code>original_basis</code> to <code>new_basis</code>. The change of basis matrix from basis A to basis B is defined to be: <code>S_{A -&gt; B} = [ [a_1]_B, ..., [a_n]_B ]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>original_basis</code> <code>List[List]</code> <p>A set of <code>n</code> basis vectors for :math:<code>R^{n}</code> or <code>m</code> basis vectors for a subspace of :math:<code>R^{n}</code>.</p> required <code>new_basis</code> <code>List[List]</code> <p>A set of <code>n</code> basis vectors for :math:<code>R^{n}</code> or <code>m</code> basis vectors for a subspace of :math:<code>R^{n}</code>.</p> required <code>inv</code> <code>bool</code> <p>Whether to return the inverse of the change of basis matrix, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The change of basis matrix or the inverse of it, which translates from <code>new_basis</code> back to <code>original_basis</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; # Change of basis from [[1, 2, -3], [4, -1, -3]] to [[0, 1, -1], [1, 0, -1]]\n&gt;&gt;&gt; la.MatrixOps.cob_mat([[1, 2, -3], [4, -1, -3]], [[0, 1, -1], [1, 0, -1]], False)\narray([[ 2., -1.],\n       [ 1.,  4.]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.col_space","title":"<code>col_space()</code>","text":"<p>Returns a list of vectors (np.ndarray objects) that span the column-space or image of X.</p> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>A list of columns vectors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [3, 4], [5, 6]], axis=0)\n&gt;&gt;&gt; [array([[1.],\n            [3.],\n            [5.]]),\n    array([[2.],\n            [4.],\n            [6.]])]\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.diagonalize","title":"<code>diagonalize(reals_only=False, sort=False, normalize=False)</code>","text":"<p>Return (P, D), where D is a diagonal D = P^-1 * M * P where M is current matrix.</p> <p>Parameters:</p> Name Type Description Default <code>reals_only</code> <code>bool</code> <p>Whether to throw an error if complex numbers are need to diagonalize, by default False.</p> <code>False</code> <code>sort</code> <code>bool</code> <p>Whether to sort the eigenvalues along the diagonal, by default False.</p> <code>False</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize the eigenvector columns of P, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>A tuple (P, D).</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>The matrix X must be square.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [2, 1]], axis=1)\n&gt;&gt;&gt; m.diagonalize()\n(array([[-1.,  1.],\n        [ 1.,  1.]]),\n array([[-1.,  0.],\n        [ 0.,  3.]]))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.eigen","title":"<code>eigen(real=True)</code>","text":"<p>Find the eigenvalues and eigenvectors of the matrix <code>X</code>.</p> <p>Parameters:</p> Name Type Description Default <code>real</code> <code>bool</code> <p>Whether to convert the array of eigenvalues to real numbers, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>w (\u2026, M) array</code> <p>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When <code>X</code> is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs.</p> <code>vl(\u2026, M, M) array</code> <p>The normalized (unit \u201clength\u201d) left eigenvectors, such that the column v[:,i] is the eigenvector corresponding to the eigenvalue w[i].</p> <code>vr(\u2026, M, M) array</code> <p>The normalized (unit \u201clength\u201d) right eigenvectors, such that the column v[:,i] is the eigenvector corresponding to the eigenvalue w[i].</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>The matrix X must be square.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [2, 1]], axis=0)\n&gt;&gt;&gt; m.eigen()\n(array([ 3., -1.]),\n array([[ 0.70710678, -0.70710678],\n        [ 0.70710678,  0.70710678]]),\n array([[ 0.70710678, -0.70710678],\n        [ 0.70710678,  0.70710678]]))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.eye","title":"<code>eye(N, M=None, k=0, dtype=np.dtype(np.int8))</code>  <code>classmethod</code>","text":"<p>Instantiate a class instance with an identity matrix.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of rows.</p> required <code>M</code> <code>Optional[int]</code> <p>Number of columns, by default None, which takes the value of N.</p> <code>None</code> <code>k</code> <code>int</code> <p>Index of the diagonal where 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal, by default 0.</p> <code>0</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data-type of identity matrix, by default np.int8.</p> <code>dtype(int8)</code> <p>Returns:</p> Type Description <code>MatrixOps</code> <p>An instance of of class MatrixOps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; la.MatrixOps.eye(3)\narray([[1, 0, 0],\n       [0, 1, 0],\n       [0, 0, 1]], dtype=int8)\n&gt;&gt;&gt; la.MatrixOps.eye(3, 4, 1)\narray([[0, 1, 0, 0],\n       [0, 0, 1, 0],\n       [0, 0, 0, 1]], dtype=int8)\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.gs","title":"<code>gs(ret_type='matrix')</code>","text":"<p>Create an orthogonal matrix (a set of orthonormal basis vectors) for matrix <code>X</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ret_type</code> <code>str</code> <p>Whether to return a set of orthonormal basis vectors or an orthogonal matrix, by default 'matrix'.</p> <code>'matrix'</code> <p>Returns:</p> Type Description <code>ndarray or MatrixOps</code> <p>A set of orthonormal basis vectors or an orthogonal matrix, depending on the <code>ret_type</code> argument.</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>The matrix X must be square.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 0], [0, 1], [1, 1]], axis=0)\n&gt;&gt;&gt; m.gs(ret_type=\"vector\")\n[array([-0.70710678, -0.        , -0.70710678]), array([ 0.40824829, -0.81649658, -0.40824829])]\n&gt;&gt;&gt; m.gs(ret_type=\"matrix\")\narray([[-0.70710678,  0.40824829],\n       [-0.        , -0.81649658],\n       [-0.70710678, -0.40824829]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.inv","title":"<code>inv()</code>","text":"<p>Given a square matrix <code>X</code>, return the matrix <code>Xinv</code> satisfying <code>dot(X, Xinv) = dot(Xinv, X) = eye(X.shape[0])</code>.</p> <p>Returns:</p> Type Description <code>MatrixOps</code> <p>The inverse of X.</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>If <code>X</code> is not square or inversion fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [3, 4]], axis=0)\n&gt;&gt;&gt; m.inv()\narray([[-2. ,  1. ],\n       [ 1.5, -0.5]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.is_coord_vec","title":"<code>is_coord_vec(original_vec, coord_vec, *args)</code>  <code>staticmethod</code>","text":"<p>Test if <code>coord_vec</code> is the coordinate vector with respect to a set of basis vectors <code>basis_vecs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>original_vec</code> <code>Union[ndarray, List, Tuple]</code> <p>The original vector in its original coordinate.</p> required <code>coord_vec</code> <code>Union[ndarray, List, Tuple]</code> <p>A coordinate vector.</p> required <code>args</code> <code>Union[ndarray, List, Tuple]</code> <p>An arbitrary number of basis vectors.</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>coord_vec</code> is the coordinate vector with respect to the basis vectors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; original_vec = np.array([5, 11])\n&gt;&gt;&gt; coord_vec = [1, 2]\n&gt;&gt;&gt; basis_vecs = [np.array([1, 3]), np.array([2, 4])]\n&gt;&gt;&gt; la.MatrixOps.is_coord_vec(original_vec, coord_vec, *basis_vecs)\nTrue\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.is_pos_def","title":"<code>is_pos_def()</code>","text":"<p>Check if matrix <code>X</code> is positive definite. A symmetric matrix A is positive definite if (and only if) all of its eigenvalues are positive. The matrix A is positive sem-definite if  (and only if) all of its eigenvalues are non-negative (positive or zero).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if positive definite or False if non-positive definite.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps.eye(3)\n&gt;&gt;&gt; m.is_pos_def()\nTrue\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.is_sq","title":"<code>is_sq()</code>","text":"<p>Check if matrix <code>X</code> is square.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if square or False if non-square.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; la.MatrixOps(np.array([[1, 2], [3, 4]]), axis=0).is_sq()\nTrue\n&gt;&gt;&gt; la.MatrixOps(np.array([[1, 2], [3, 4], [5, 6]]), axis=0).is_sq()\nFalse\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.null_space","title":"<code>null_space()</code>","text":"<p>Returns a list of vectors (np.ndarray objects) that span the null-space or kernel of X.</p> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>A list of columns vectors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [3, 6]], axis=0)\n&gt;&gt;&gt; m.null_space()\n&gt;&gt;&gt; [array([[-2.],\n            [ 1.]])]\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.pinv","title":"<code>pinv()</code>","text":"<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix. Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all large singular values.</p> <p>Returns:</p> Name Type Description <code>B</code> <code>(..., N, M) MatrixOps</code> <p>The pseudo-inverse of <code>X</code>.</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>If the SVD computation does not converge.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2], [3, 4], [5, 6]], axis=1)\n&gt;&gt;&gt; m.pinv()\narray([[-1.33333333,  1.08333333],\n       [-0.33333333,  0.33333333],\n       [ 0.66666667, -0.41666667]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.power","title":"<code>power(n)</code>","text":"<p>Raise a square matrix to the (integer) power n.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The exponent can be any integer or long integer, positive, negative, or zero.</p> required <p>Returns:</p> Type Description <code>MatrixOps</code> <p>An instance of class MatrixOps.</p> <p>Raises:</p> Type Description <code>LinAlgError</code> <p>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; la.MatrixOps(np.array([[1, 2], [12, 17]]), axis=0).power(2)\narray([[ 25,  36],\n       [216, 313]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.rapprox_rank_k","title":"<code>rapprox_rank_k(k, n_oversamples=None, n_iters=None, return_onb=True)</code>","text":"<p>Computes the rank-k approximation of the matrix X using randomized SVD. The matrix approximation can be constructed as the matrix product <code>u @ np.diag(s) @ vh</code> where (u, s, vh) are the tuple returned by calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The rank of the approximation.</p> required <code>n_oversamples</code> <code>Optional[int]</code> <p>Additional number of random vectors to sample the column space of X so as to ensure proper conditioning.</p> <code>None</code> <code>n_iters</code> <code>Optional[int]</code> <p>Number of power iterations.</p> <code>None</code> <code>return_onb</code> <code>Optional[bool]</code> <p>Whether to return the orthonormal basis Q for the approximated column space of X.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[Tuple[ndarray, ndarray, ndarray], Tuple[ndarray, ndarray, ndarray, ndarray]]</code> <p>The singular values, left, right singular vectors needed to construct the rank-k approximation of the matrix X. Optionally, the orthonormal basis Q for the approximated column space of X can be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 0, 12], [7, 12, 17], [9, 77, 27], [8, 7, 16]], axis=0)\n&gt;&gt;&gt; m.rapprox_rank_k(2)\n(array([[-0.05593827,  0.49093673],\n        [-0.2166436 ,  0.55228019],\n        [-0.96140112, -0.25677546],\n        [-0.16013852,  0.62292382]]),\n array([85.19359971, 21.49336595]),\n array([[-0.13505899, -0.91261056, -0.38587696],\n        [ 0.32704554, -0.40867874,  0.85206978]]),\n array([[-0.58506352, -0.35851766, -0.70637316,  0.17378931],\n        [-0.31208547, -0.44629115,  0.29152198, -0.78641071],\n        [ 0.67509565, -0.71187709, -0.18086095,  0.06903766],\n        [-0.3233407 , -0.40684188,  0.61914555,  0.58871833]]))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.rref","title":"<code>rref(pivots=False)</code>","text":"<p>Return the reduced row-echelon form of the matrix. Use <code>pivots</code> to return the indices of pivot columns.</p> <p>Parameters:</p> Name Type Description Default <code>pivots</code> <code>bool</code> <p>Whether to return a tuple of pivot indices, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>MatrixOps or tuple</code> <p>The reduced row-echelon from or a tuple of pivot column indices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 2, 3], [4, 5, 6], [7, 8, 9]], axis=1)\n&gt;&gt;&gt; m.rref()\narray([[1., 0., -1.],\n       [0., 1.,  2.],\n       [0., 0.,  0.]])\n&gt;&gt;&gt; m.rref(pivots=True)\n(array([[1., 0., -1.],\n        [0., 1.,  2.],\n        [0., 0.,  0.]]), (0, 1))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.sv_plot","title":"<code>sv_plot()</code>","text":"<p>Plot the log and cumulative sum of singular values of the matrix X. This can be used to visually assess how much information is captured by the first k-rank of the matrix X, so that a sensible number can be selected for <code>k</code> for rank-k matrix approximation.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 0, 12], [7, 12, 17], [9, 77, 27], [8, 7, 16]], axis=0)\n&gt;&gt;&gt; m.sv_plot()\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.svd","title":"<code>svd(full_matrices=True, sigma_only=False)</code>","text":"<p>Factorizes the matrix X into two unitary matrices U and Vh, and a 1-D array s of singular values (real, non-negative) such that a == U @ S @ Vh, where S is a suitably shaped matrix of zeros with main diagonal s.</p> <p>Parameters:</p> Name Type Description Default <code>full_matrices</code> <code>Optional[bool]</code> <p>If True, u and vh have the shapes (..., M, M) and (..., N, N), respectively. Otherwise, the shapes are (..., M, K) and (..., K, N), respectively, where K = min(M, N)., by default True.</p> <code>True</code> <code>sigma_only</code> <code>Optional[bool]</code> <p>Whether to return the singular values only, by default False, which constructs the sigma matrix in SVD from the singular values.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>A tuple of three matrices: U (m x m), S (m x n), V^T (n x n) if full_matrices=True. If full_matrices=False and sigma_only=False, S is K x K. If sigma_only=True, the middle return is the 1-D array of singular values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; m = la.MatrixOps([[1, 0], [71, 1], [12, 1]], axis=1)\n&gt;&gt;&gt; m.svd()\n(array([[-0.99987192, -0.01600465],\n        [-0.01600465,  0.99987192]]),\n array([[72.02311126,  0.        ,  0.        ],\n        [ 0.        ,  0.81941679,  0.        ]]),\n array([[-0.01388265, -0.98589063, -0.16681406],\n        [-0.01953176, -0.16653093,  0.98584277],\n        [-0.99971285,  0.01694429, -0.01694429]]))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.MatrixOps.zeros","title":"<code>zeros(shape, dtype=np.dtype(np.float64))</code>  <code>classmethod</code>","text":"<p>Instantiate a class instance with a zero matrix.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Tuple[int]</code> <p>Shape of the zero matrix, e.g. (2, 4).</p> required <code>dtype</code> <code>Optional[dtype]</code> <p>The desired data-type for the matrix, by default np.float64.</p> <code>dtype(float64)</code> <p>Returns:</p> Type Description <code>MatrixOps</code> <p>An instance of of class MatrixOps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; la.MatrixOps.zeros((2, 3))\narray([[0., 0., 0.],\n       [0., 0., 0.]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.cob","title":"<code>cob(vector, *args)</code>","text":"<p>Express a vector in a new basis spanned by a pairwise orthogonal (not orthonormal) set of basis vectors.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Union[ndarray, List, Tuple]</code> <p>An n-dimensional vector.</p> required <code>args</code> <code>Union[ndarray, List, Tuple]</code> <p>An arbitrary number of pairwise orthogonal n-dimensional basis vectors.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The original vector expressed in a new basis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; # Express [10, -5] in the basis spanned by [3, 4] and [4, -3]\n&gt;&gt;&gt; la.cob(vector=np.array([10, -5]), np.array([3, 4]), np.array([4, -3]))\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.lin_ind","title":"<code>lin_ind(*args)</code>","text":"<p>Check if the input vectors are linearly independent. If not, return the redundant column vectors as an <code>np.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Union[ndarray, List, Tuple]</code> <p>An arbitrary number of vectors.</p> <code>()</code> <p>Returns:</p> Type Description <code>None or ndarray</code> <p>An <code>np.ndarray</code> of redundant columns or None if the input vectors are linearly independent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; # Linear independent\n&gt;&gt;&gt; la.lin_ind([1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 1, 0, 0])\nThe matrix with input vectors as columns has full column rank, and so the input vectors are linearly independent\n&gt;&gt;&gt; # Linear dependent\n&gt;&gt;&gt; la.lin_ind([1, 0, 0, 0], [1, 9, 3, 0], [0, 0, 4, 1], [0, 1, 0, 0], [2, 3, 4, 9])\narray([[2., 3., 4., 9.]])\n</code></pre>"},{"location":"linear_algebra/#src.math_tools.linalg.proj","title":"<code>proj(v_1, v_2, proj_type='vector')</code>","text":"<p>Obtain the scalar or vector projection of vector <code>v1</code> onto vector <code>v2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v_1</code> <code>Union[ndarray, List, Tuple]</code> <p>An n-dimensional vector.</p> required <code>v2</code> <code>Union[ndarray, List, Tuple]</code> <p>An n-dimensional vector.</p> required <code>proj_type</code> <code>str</code> <p>Type of projection, by default 'vector'.</p> <code>'vector'</code> <p>Returns:</p> Type Description <code>ndarray or float</code> <p>The scalar or vector projection of vector <code>v1</code> onto vector <code>v2</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import linalg as la\n&gt;&gt;&gt; la.proj(np.array([2, 4, 0]), np.array([4, 2, 4]), 'scalar')\n2.6666666666666665\n&gt;&gt;&gt; la.proj(np.array([2, 1]), np.array([3, -4]), 'vector')\narray([ 0.24, -0.32])\n</code></pre>"}]}